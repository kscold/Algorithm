# 이 문제의 핵심 아이디어는 빼기는 덜 이용하되, 최대한 많이 나누기이다.
# 그리디로써 최대한 많이 나누면 숫자가 작아지는 속도가 빠르기 때문에 결과적으로 최소의 값을 반환하게 된다.

n, k = map(int, input().split())

result = 0

# N이 K 이상이라면 K로 계속 나누기
while n >= k:
    # N이 K로 나누어 떨어지지 않는다면 N에서 1씩 빼기
    while n % k != 0:
        n -= 1
        result += 1

    # K로 나누기
    n //= k
    result += 1

# 마지막으로 남은 수에 대하여 1씩 빼기(중요)
while n > 1:
    n -= 1
    result += 1

print(result)

# 그러나 위의 코드의 경우, 마지막 n이 k보다 작을 때 -1식 하는 과정이 n이 꺼지면 성능이 안좋아 진다. 따라서 3-6 코드에서 보완한다.

